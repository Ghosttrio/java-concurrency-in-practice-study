- 동시에 실행하는 프로그램은 순차적으로 실행하는 프로그램보다 오류 발생 가능성이 높음에도 불구하고 왜 작업을 동시에 실행하는 문제에 신경을 써야 하는가?
    - 스레드는 자바 언어에서 피할 수 없는 특성이고, 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발할 수 있게 해주기 때문이다.
    - 스레드는 멀티프로세스 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다.

## 1.1 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사

- 운영체제는 여러 개의 프로그램을 각자의 프로세스 내에서 동시에 실행할 수 있도록 발전됐다.
- 운영체제를 개발하게 된 몇 가지 요인 : 자원 활용, 공정성, 편의성
- 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 가지고 스레드가 고안됐다.
- 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존할 수 있다.
- 스레드는 프로세스에 할당된 자원을 공유한다. 하지만 각 스레드는 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다.
- 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존할 수 있다.
- 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당한다.
- 공유된 데이터에 접근하는 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수 있다.

## 1.2 스레드의 이점

#### 1.2.1 멀티프로세서 활용

- 프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다.
- 프로세서가 두 개인 시스템에서 스레드가 하나뿐인 프로그램을 실행하면 CPU 자원의 50%를 낭비하는 셈이다. 100개라면 99% 낭비
- 여러 개의 스레드를 사용하면 프로세서가 하나라 해도 처리 속도를 높일 수 있다.

#### 1.2.2 단순한 모델링 

- 순차적으로 처리하는 프로그램은 작성하기 쉽고 오도 별로 생기지 않고 테스트하기 쉽다.
- 종류별 작업마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리할 수 있다.
- 복잡하면서 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다. ex) 서블릿
- 웹 요청이 들어와서 서블릿의 service 메서드가 호출될 때 해당 요청을 마치 단일 스레드 프로그램인 것처럼 처리할 수 있다.

#### 1.2.3 단순한 비동기 이벤트 처리

- 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결 마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다. 

## 1.3 스레드 사용의 위험성

#### 1.3.1 안정성 위해 요소

```java
@NotThreadSafe
public class UnsafeSequence {

    private int value;

    public int getNext() {
        return value++;
    }
}
```
- 스레드가 하나일 때는 아무런 문제가 없지만 스레드가 여럿일 때는 제대로 동작하지 않는다.
- 변수 값을 1 증가시키는 value++ 연산은 얼핏 하나의 연산 같지만, 사실 별도의 3개 연산으로 구성되어 있다.
- 여러 스레드에서 실행되는 연산은 서로 간에 무작위로 끼어 들 수 있으므로 스레드 두 개가 동시에 같은 값을 읽고 각자 1을 더할 가능성이 있다.
- 경쟁조건(race condition)이라고 하는 흔한 위험성을 보여준다.
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있다.
- 이는 상당히 편리하면서 위험하다.
- 멀티스레드 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야 한다.

```java
@ThreadSafe
public class Sequence {

    @GuardedBy("this")
    private int value;

    public synchronized int getNext() {
        return value++;
    }
}
```

#### 1.3.2 활동성 위험
- 안정성이 "잘못된 일이 생기지 않는다"는 것을 뜻하는 반면, 활동성은 "원하는 일이 결국 일어난다"는 보완적인 목표에 관한 것이다.
- 어떤 작업이 전혀 진전되지 못하는 상태에 빠질 때 활동성 장애가 발생했다고 한다.
- 스레드를 사용하면 활동성 문제의 위험성이 크게 높아진다.

#### 1.3.3 성능 위험
- 성능 문제는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄한다.
- 스레드가 많은 프로그램은 컨텍스트 스위칭이 빈번하며 부담이 생긴다.
- 실행중인 컨텍스트를 저장하고 다시 읽어들여야 하며, 메모리를 읽고 쓰는 데 있어 지역성이 손실되고, CPU 시간을 스케줄링하는 데 소모해야 한다. 또한 동기화 기능도 사용해야 한다.
- 이런 모든 요인은 성능 측면에서 추가적인 손실을 유발한다. 

